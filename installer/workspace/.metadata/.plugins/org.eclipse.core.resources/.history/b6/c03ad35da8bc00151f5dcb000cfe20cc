/*
 Copyright (C) 2011 J. Coliz <maniacbug@ymail.com>

 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License
 version 2 as published by the Free Software Foundation.
 */

/**
 * Example using Dynamic Payloads
 *
 * This is an example of how to use payloads of a varying (dynamic) size.
 */

/*
 * Transmit data -> tunggu konfirmasi -> reply ok/ng
 */

#include <SPI.h>
#include "nRF24L01.h"
#include "RF24.h"

//
// Hardware configuration
//

// Set up nRF24L01 radio on SPI bus plus pins 7 & 8

RF24 radio(7, 8);

//
// Topology
//

// Radio pipe addresses for the 2 nodes to communicate.
// Ddy: This arduino pipe address is pipe[0], the second one is writing address by rpi-hub
const uint64_t pipes[2] = { 0xF0F0F0F0E1LL, 0xF0F0F0F0D2LL };

//
// Payload
//

const int max_payload_size = 32;
char receive_payload[max_payload_size + 1]; // +1 to allow room for a terminating NULL char

void setup(void) {

	//
	// Print preamble
	//

	Serial.begin(115200);

	//
	// Setup and configure rf radio
	//

	radio.begin();

	// enable dynamic payloads
	radio.enableDynamicPayloads();

	// optionally, increase the delay between retries & # of retries
	radio.setRetries(5, 15);

	//
	// Open pipes to other nodes for communication
	//

	// This simple sketch opens two pipes for these two nodes to communicate
	// back and forth.
	// Open 'our' pipe for writing
	// Open the 'other' pipe for reading, in position #1 (we can have up to 5 pipes open for reading)

	radio.openWritingPipe(pipes[0]);
	radio.openReadingPipe(1, pipes[1]);

	//
	// Start listening
	//

	radio.startListening();

	//
	// Dump the configuration of the rf unit for debugging
	//

	radio.printDetails();
}

void loop() {

	// First, stop listening so we can talk.
	radio.stopListening();

	static char kata[] = "Arduino to Raspberry Pi2 ...";
	radio.write(kata, sizeof(kata));

	// Now, continue listening
	radio.startListening();

	// Wait here until we get a response, or timeout
	unsigned long started_waiting_at = millis();
	bool timeout = false;
	while (!radio.available() && !timeout)
		if (millis() - started_waiting_at > 500)
			timeout = true;

	// Describe the results
	if (timeout) {
		Serial.println(F("Failed, response timed out..."));
	} else {
		// Grab the response, compare, and send to debugging spew
		uint8_t len = radio.getDynamicPayloadSize();

		// If a corrupt dynamic payload is received, it will be flushed
		if (!len) {
			return;
		}

		radio.read(receive_payload, len);

		// Put a zero at the end for easy printing
		receive_payload[len] = 0;

		// Spew it
		Serial.print(F("Got response size="));
		Serial.print(len);
		Serial.print(F(" value="));
		Serial.println(receive_payload);
	}

	// Try again 1s later
	delay(700);  // Ddy:
}
